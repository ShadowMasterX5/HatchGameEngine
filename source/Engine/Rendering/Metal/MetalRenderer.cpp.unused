#if INTERFACE
#include <Engine/Includes/Standard.h>
#include <Engine/Includes/StandardSDL2.h>
#include <Engine/ResourceTypes/ISprite.h>
#include <Engine/Rendering/Texture.h>
#include <Engine/Includes/HashMap.h>

#include <stack>

class MetalRenderer {
public:
};
#endif

// Shader
// https://github.com/spurious/SDL-mirror/blob/master/src/render/metal/SDL_shaders_metal.metal
// Renderer
// https://github.com/spurious/SDL-mirror/blob/master/src/render/metal/SDL_render_metal.m

#ifdef MACOSXAAAAAAAAAAAAAA

#include <Engine/Rendering/Metal/MetalRenderer.h>

#include <Engine/Application.h>
#include <Engine/Diagnostics/Log.h>
#include <Engine/Rendering/Texture.h>

struct Vertex {
    float x, y, z;
    int color;
    float u, v;
};
struct Metal_RenderData {
    void*                  Metal_DLL;
    IDirect3D9*            D3D;
    IDirect3DDevice9*      Device;
    UINT                   Adapter;
    D3DPRESENT_PARAMETERS  PresentParams;
    bool                   UpdateBackBufferSize;
    bool                   BeginScene;
    bool                   EnableSeparateAlphaBlend;
    IDirect3DSurface9*     DefaultRenderTarget;
    IDirect3DSurface9*     CurrentRenderTarget;
    void*                  D3Dx_DLL;
    LPDIRECT3DPIXELSHADER9 Shaders[NUM_SHADERS];
};
struct Metal_TextureData {
    bool   Dirty;
    DWORD  Usage;
    Uint32 Format;
    D3DFORMAT D3DFormat;
    IDirect3DTexture9* Texture;
    IDirect3DTexture9* Staging;
    D3DTEXTUREFILTERTYPE ScaleMode;
};

MetalShader*         Metal_CurrentShader = NULL;
MetalShader*         Metal_SelectedShader = NULL;
MetalShader*         Metal_ShaderShape = NULL;
MetalShader*         Metal_ShaderTexturedShape = NULL;

int                Metal_DefaultFramebuffer;
Vertex*            Metal_BufferCircleFill;
Vertex*            Metal_BufferCircleStroke;
Vertex*            Metal_BufferSquareFill;

Uint32             Metal_BlendColorsAsHex = 0;

bool               Metal_PixelPerfectScale = false;
float              Metal_RenderScaleX = 1.0f;
float              Metal_RenderScaleY = 1.0f;
Matrix4x4*         Metal_MatrixIdentity = NULL;

DWORD              Metal_Blend_SRC_COLOR = D3DBLEND_SRCALPHA;
DWORD              Metal_Blend_DST_COLOR = D3DBLEND_INVSRCALPHA;
DWORD              Metal_Blend_SRC_ALPHA = D3DBLEND_SRCALPHA;
DWORD              Metal_Blend_DST_ALPHA = D3DBLEND_INVSRCALPHA;

Metal_RenderData*    renderData = NULL;

bool        Metal_LoadDLL(void** pD3DDLL, IDirect3D9** pDirect3D9Interface) {
    *pD3DDLL = SDL_LoadObject("D3D9.DLL");
    if (*pD3DDLL) {
        typedef IDirect3D9 *(WINAPI *Direct3DCreate9_t) (UINT SDKVersion);
        Direct3DCreate9_t Direct3DCreate9Func;

        #ifdef USE_D3D9EX
            typedef HRESULT (WINAPI *Direct3DCreate9Ex_t)(UINT SDKVersion, IDirect3D9Ex **ppD3D);
            Direct3DCreate9Ex_t Direct3DCreate9ExFunc;

            Direct3DCreate9ExFunc = (Direct3DCreate9Ex_t)SDL_LoadFunction(*pD3DDLL, "Direct3DCreate9Ex");
            if (Direct3DCreate9ExFunc) {
                IDirect3D9Ex *pDirect3D9ExInterface;
                HRESULT hr = Direct3DCreate9ExFunc(Metal_SDK_VERSION, &pDirect3D9ExInterface);
                if (SUCCEEDED(hr)) {
                    const GUID IDirect3D9_GUID = { 0x81bdcbca, 0x64d4, 0x426d, { 0xae, 0x8d, 0xad, 0x1, 0x47, 0xf4, 0x27, 0x5c } };
                    hr = IDirect3D9Ex_QueryInterface(pDirect3D9ExInterface, &IDirect3D9_GUID, (void**)pDirect3D9Interface);
                    IDirect3D9Ex_Release(pDirect3D9ExInterface);
                    if (SUCCEEDED(hr)) {
                        return true;
                    }
                }
            }
        #endif /* USE_D3D9EX */

        Direct3DCreate9Func = (Direct3DCreate9_t)SDL_LoadFunction(*pD3DDLL, "Direct3DCreate9");
        if (Direct3DCreate9Func) {
            *pDirect3D9Interface = Direct3DCreate9Func(Metal_SDK_VERSION);
            if (*pDirect3D9Interface) {
                return true;
            }
        }

        SDL_UnloadObject(*pD3DDLL);
        *pD3DDLL = NULL;
    }
    *pDirect3D9Interface = NULL;
    return false;
}
void        Metal_InitRenderState() {
    D3DMATRIX matrix;

    IDirect3DDevice9* device = renderData->Device;

    IDirect3DDevice9_SetVertexShader(device, NULL);
    IDirect3DDevice9_SetFVF(device, D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
    // IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, D3DZB_FALSE);
    IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, D3DZB_TRUE);
    IDirect3DDevice9_SetRenderState(device, D3DRS_CULLMODE, D3DCULL_NONE);
    IDirect3DDevice9_SetRenderState(device, D3DRS_LIGHTING, FALSE);

    /* Enable color modulation by diffuse color */
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

    /* Enable alpha modulation by diffuse alpha */
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(device, 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

    /* Enable separate alpha blend function, if possible */
    if (renderData->EnableSeparateAlphaBlend) {
        IDirect3DDevice9_SetRenderState(device, D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
    }

    /* Disable second texture stage, since we're done */
    IDirect3DDevice9_SetTextureStageState(device, 1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    IDirect3DDevice9_SetTextureStageState(device, 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

    /* Set an identity world and view matrix */
    matrix.m[0][0] = 1.0f;
    matrix.m[0][1] = 0.0f;
    matrix.m[0][2] = 0.0f;
    matrix.m[0][3] = 0.0f;
    matrix.m[1][0] = 0.0f;
    matrix.m[1][1] = 1.0f;
    matrix.m[1][2] = 0.0f;
    matrix.m[1][3] = 0.0f;
    matrix.m[2][0] = 0.0f;
    matrix.m[2][1] = 0.0f;
    matrix.m[2][2] = 1.0f;
    matrix.m[2][3] = 0.0f;
    matrix.m[3][0] = 0.0f;
    matrix.m[3][1] = 0.0f;
    matrix.m[3][2] = 0.0f;
    matrix.m[3][3] = 1.0f;
    IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &matrix);
    IDirect3DDevice9_SetTransform(device, D3DTS_VIEW, &matrix);

    /* Reset our current scale mode */
    // SDL_memset(renderData->ScaleMode, 0xFF, sizeof(renderData->ScaleMode));

    /* Start the render with BeginScene */
    renderData->BeginScene = true;
}
void        Metal_MakeShaders() {
    // Metal_ShaderShape             = new MetalShader(vertexShaderSource, sizeof(vertexShaderSource), fragmentShaderSource_Shape, sizeof(fragmentShaderSource_Shape));
    // Metal_ShaderTexturedShape     = new MetalShader(vertexShaderSource, sizeof(vertexShaderSource), fragmentShaderSource_TexturedShape, sizeof(fragmentShaderSource_TexturedShape));
    // ShaderTexturedShapeBGRA = new MetalShader(vertexShaderSource, sizeof(vertexShaderSource), fragmentShaderSource_TexturedShapeBGRA, sizeof(fragmentShaderSource_TexturedShapeBGRA));
}
void        Metal_MakeShapeBuffers() {
    Vertex* buffer;

    Metal_BufferCircleFill = (Vertex*)Memory::TrackedMalloc("MetalRenderer::Metal_BufferCircleFill", 362 * sizeof(Vertex));
    buffer = Metal_BufferCircleFill;
    buffer[0] = Vertex { 0.0f, 0.0f, 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    for (int i = 0; i < 361; i++) {
        buffer[i + 1] = Vertex { cos(i * M_PI / 180.0f), sin(i * M_PI / 180.0f), 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    }

    Metal_BufferCircleStroke = (Vertex*)Memory::TrackedMalloc("MetalRenderer::Metal_BufferCircleStroke", 361 * sizeof(Vertex));
    buffer = (Vertex*)Metal_BufferCircleStroke;
    for (int i = 0; i < 361; i++) {
        buffer[i + 0] = Vertex { cos(i * M_PI / 180.0f), sin(i * M_PI / 180.0f), 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    }

    Metal_BufferSquareFill = (Vertex*)Memory::TrackedMalloc("MetalRenderer::Metal_BufferSquareFill", 4 * sizeof(Vertex));
    buffer = (Vertex*)Metal_BufferSquareFill;
    buffer[0] = Vertex { 0.0f, 0.0f, 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    buffer[1] = Vertex { 1.0f, 0.0f, 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    buffer[2] = Vertex { 1.0f, 1.0f, 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
    buffer[3] = Vertex { 0.0f, 1.0f, 0.0f, 0xFFFFFFFF, 0.0f, 0.0f };
}
const char* Metal_GetResultString(HRESULT result) {
    switch (result) {
    case D3DERR_WRONGTEXTUREFORMAT:
        return "WRONGTEXTUREFORMAT";
    case D3DERR_UNSUPPORTEDCOLOROPERATION:
        return "UNSUPPORTEDCOLOROPERATION";
    case D3DERR_UNSUPPORTEDCOLORARG:
        return "UNSUPPORTEDCOLORARG";
    case D3DERR_UNSUPPORTEDALPHAOPERATION:
        return "UNSUPPORTEDALPHAOPERATION";
    case D3DERR_UNSUPPORTEDALPHAARG:
        return "UNSUPPORTEDALPHAARG";
    case D3DERR_TOOMANYOPERATIONS:
        return "TOOMANYOPERATIONS";
    case D3DERR_CONFLICTINGTEXTUREFILTER:
        return "CONFLICTINGTEXTUREFILTER";
    case D3DERR_UNSUPPORTEDFACTORVALUE:
        return "UNSUPPORTEDFACTORVALUE";
    case D3DERR_CONFLICTINGRENDERSTATE:
        return "CONFLICTINGRENDERSTATE";
    case D3DERR_UNSUPPORTEDTEXTUREFILTER:
        return "UNSUPPORTEDTEXTUREFILTER";
    case D3DERR_CONFLICTINGTEXTUREPALETTE:
        return "CONFLICTINGTEXTUREPALETTE";
    case D3DERR_DRIVERINTERNALERROR:
        return "DRIVERINTERNALERROR";
    case D3DERR_NOTFOUND:
        return "NOTFOUND";
    case D3DERR_MOREDATA:
        return "MOREDATA";
    case D3DERR_DEVICELOST:
        return "DEVICELOST";
    case D3DERR_DEVICENOTRESET:
        return "DEVICENOTRESET";
    case D3DERR_NOTAVAILABLE:
        return "NOTAVAILABLE";
    case D3DERR_OUTOFVIDEOMEMORY:
        return "OUTOFVIDEOMEMORY";
    case D3DERR_INVALIDDEVICE:
        return "INVALIDDEVICE";
    case D3DERR_INVALIDCALL:
        return "INVALIDCALL";
    case D3DERR_DRIVERINVALIDCALL:
        return "DRIVERINVALIDCALL";
    case D3DERR_WASSTILLDRAWING:
        return "WASSTILLDRAWING";
    default:
        return "UNKNOWN";
    }
    return NULL;
}
D3DFORMAT   Metal_PixelFormatToD3DFORMAT(Uint32 format) {
    switch (format) {
    case SDL_PIXELFORMAT_RGB565:
        return D3DFMT_R5G6B5;
    case SDL_PIXELFORMAT_RGB888:
        return D3DFMT_X8R8G8B8;
    case SDL_PIXELFORMAT_ARGB8888:
        return D3DFMT_A8R8G8B8;
    case SDL_PIXELFORMAT_YV12:
    case SDL_PIXELFORMAT_IYUV:
    case SDL_PIXELFORMAT_NV12:
    case SDL_PIXELFORMAT_NV21:
        return D3DFMT_L8;
    default:
        return D3DFMT_UNKNOWN;
    }
}
Uint32      Metal_D3DFORMATToPixelFormat(D3DFORMAT format) {
    switch (format) {
        case D3DFMT_R5G6B5:
            return SDL_PIXELFORMAT_RGB565;
        case D3DFMT_X8R8G8B8:
            return SDL_PIXELFORMAT_RGB888;
        case D3DFMT_A8R8G8B8:
            return SDL_PIXELFORMAT_ARGB8888;
        default:
            return SDL_PIXELFORMAT_UNKNOWN;
    }
    return SDL_PIXELFORMAT_UNKNOWN;
}
int         Metal_SetError(const char* error, HRESULT result) {
    Log::Print(Log::LOG_ERROR, "D3D: %s (%s)", error, Metal_GetResultString(result));
    exit(0);
    return 0;
}

void        Metal_CreateTexture(Texture* texture) {
    texture->DriverData = Memory::TrackedCalloc("Texture::DriverData", 1, sizeof(Metal_TextureData));

    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;

    textureData->ScaleMode = Graphics::TextureInterpolate ? D3DTEXF_LINEAR : D3DTEXF_POINT;

    DWORD usage = 0;
    if (texture->Access == SDL_TEXTUREACCESS_TARGET)
        usage = D3DUSAGE_RENDERTARGET;

    // Metal_CreateTextureRep
    HRESULT result;
    textureData->Dirty = false;
    textureData->Usage = usage;
    textureData->Format = texture->Format;
    textureData->D3DFormat = Metal_PixelFormatToD3DFORMAT(texture->Format);

    result = IDirect3DDevice9_CreateTexture(renderData->Device, texture->Width, texture->Height, 1, usage, textureData->D3DFormat, D3DPOOL_DEFAULT, &textureData->Texture, NULL);
    if (FAILED(result)) {
        Log::Print(Log::LOG_ERROR, "CreateTextureD3DPOOL_DEFAULT() %s", Metal_GetResultString(result));
        Log::Print(Log::LOG_INFO, "IDirect3DDevice9_CreateTexture(%p, %u, %u, %u, %u", renderData->Device, texture->Width, texture->Height, 1, usage);
        exit(0);
    }
}
int         Metal_RecreateTexture(Texture* texture) {
    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;
    if (!textureData)
        return 0;

    if (textureData->Texture) {
        IDirect3DTexture9_Release(textureData->Texture);
        textureData->Texture = NULL;
    }
    if (textureData->Staging) {
        IDirect3DTexture9_AddDirtyRect(textureData->Staging, NULL);
        textureData->Dirty = true;
    }
    return 0;
}

int         Metal_SetRenderTarget(Texture* texture) {
    HRESULT result;
    /* Release the previous render target if it wasn't the default one */
    if (renderData->CurrentRenderTarget != NULL) {
        IDirect3DSurface9_Release(renderData->CurrentRenderTarget);
        renderData->CurrentRenderTarget = NULL;
    }

    if (texture == NULL) {
        IDirect3DDevice9_SetRenderTarget(renderData->Device, 0, renderData->DefaultRenderTarget);
        return 0;
    }

    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;
    if (!textureData) {
        SDL_SetError("Texture is not currently available");
        return -1;
    }

    /* Make sure the render target is updated if it was locked and written to */
    if (textureData->Dirty && textureData->Staging) {
        if (!textureData->Texture) {
            result = IDirect3DDevice9_CreateTexture(renderData->Device, texture->Width, texture->Height, 1, textureData->Usage, Metal_PixelFormatToD3DFORMAT(textureData->Format), D3DPOOL_DEFAULT, &textureData->Texture, NULL);
            if (FAILED(result)) {
                return Metal_SetError("CreateTexture(D3DPOOL_DEFAULT)", result);
            }
        }

        result = IDirect3DDevice9_UpdateTexture(renderData->Device, (IDirect3DBaseTexture9*)textureData->Staging, (IDirect3DBaseTexture9*)textureData->Texture);
        if (FAILED(result)) {
            return Metal_SetError("UpdateTexture()", result);
        }
        textureData->Dirty = false;
    }

    result = IDirect3DTexture9_GetSurfaceLevel(textureData->Texture, 0, &renderData->CurrentRenderTarget);
    if (FAILED(result)) {
        return Metal_SetError("GetSurfaceLevel()", result);
    }

    result = IDirect3DDevice9_SetRenderTarget(renderData->Device, 0, renderData->CurrentRenderTarget);
    if (FAILED(result)) {
        return Metal_SetError("SetRenderTarget()", result);
    }

    return 0;
}
void        Metal_Reset() {
    HRESULT result;

    /* Release the default render target before reset */
    if (renderData->DefaultRenderTarget) {
        IDirect3DSurface9_Release(renderData->DefaultRenderTarget);
        renderData->DefaultRenderTarget = NULL;
    }
    if (renderData->CurrentRenderTarget) {
        IDirect3DSurface9_Release(renderData->CurrentRenderTarget);
        renderData->CurrentRenderTarget = NULL;
    }

    /* Release application render targets */
    for (Texture* texture = Graphics::TextureHead; texture != NULL; texture = texture->Next) {
        if (texture->Access == SDL_TEXTUREACCESS_TARGET)
            MetalRenderer::DisposeTexture(texture);
        else
            Metal_RecreateTexture(texture);
    }

    result = IDirect3DDevice9_Reset(renderData->Device, &renderData->PresentParams);
    if (FAILED(result)) {
        if (result == D3DERR_DEVICELOST) {
            /* Don't worry about it, we'll reset later... */
            return;
        }
        else {
            Metal_SetError("Reset() %s", result);
            return;
        }
    }

    /* Allocate application render targets */
    for (Texture* texture = Graphics::TextureHead; texture != NULL; texture = texture->Next) {
        if (texture->Access == SDL_TEXTUREACCESS_TARGET)
            Metal_CreateTexture(texture);
    }

    IDirect3DDevice9_GetRenderTarget(renderData->Device, 0, &renderData->DefaultRenderTarget);
    Metal_InitRenderState();
    Metal_SetRenderTarget(Graphics::CurrentRenderTarget);
    MetalRenderer::UpdateViewport();
}
void        Metal_Predraw() {
    HRESULT result;

    if (renderData->UpdateBackBufferSize) {
        SDL_Window* window = Application::Window;
        int w, h;
        Uint32 window_flags = SDL_GetWindowFlags(window);
        SDL_GetWindowSize(window, &w, &h);

        renderData->PresentParams.BackBufferWidth = w;
        renderData->PresentParams.BackBufferHeight = h;
        if (window_flags & SDL_WINDOW_FULLSCREEN && (window_flags & SDL_WINDOW_FULLSCREEN_DESKTOP) != SDL_WINDOW_FULLSCREEN_DESKTOP) {
            SDL_DisplayMode fullscreen_mode;
            SDL_GetWindowDisplayMode(window, &fullscreen_mode);
            renderData->PresentParams.Windowed = FALSE;
            renderData->PresentParams.BackBufferFormat = Metal_PixelFormatToD3DFORMAT(fullscreen_mode.format);
            renderData->PresentParams.FullScreen_RefreshRateInHz = fullscreen_mode.refresh_rate;
        }
        else {
            renderData->PresentParams.Windowed = TRUE;
            renderData->PresentParams.BackBufferFormat = D3DFMT_UNKNOWN;
            renderData->PresentParams.FullScreen_RefreshRateInHz = 0;
        }

        Metal_Reset();
        // if (Metal_Reset(renderer) < 0) {
        //     return -1;
        // }

        renderData->UpdateBackBufferSize = false;
    }
    if (renderData->BeginScene) {
        result = IDirect3DDevice9_BeginScene(renderData->Device);
        if (result == D3DERR_DEVICELOST) {
            Metal_Reset();
            // if (Metal_Reset(renderer) < 0) {
            //     return -1;
            // }
            result = IDirect3DDevice9_BeginScene(renderData->Device);
        }
        if (FAILED(result)) {
            Metal_SetError("BeginScene() %s", result);
        }
        renderData->BeginScene = false;
    }
}

void        Metal_SetBlendMode() {
    IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_ALPHABLENDENABLE, TRUE);
    IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SRCBLEND, Metal_Blend_SRC_COLOR);
    IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_DESTBLEND, Metal_Blend_DST_COLOR);
    if (renderData->EnableSeparateAlphaBlend) {
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SRCBLENDALPHA, Metal_Blend_SRC_ALPHA);
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_DESTBLENDALPHA, Metal_Blend_DST_ALPHA);
    }

    // Enable multisample
    if (Graphics::MultisamplingEnabled) {
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_MULTISAMPLEANTIALIAS, TRUE);
    }
}
DWORD       Metal_GetBlendFactorFromHatch(int factor) {
    switch (factor) {
        case BlendFactor_ZERO:
            return D3DBLEND_ZERO;
        case BlendFactor_ONE:
            return D3DBLEND_ONE;
        case BlendFactor_SRC_COLOR:
            return D3DBLEND_SRCCOLOR;
        case BlendFactor_INV_SRC_COLOR:
            return D3DBLEND_INVSRCCOLOR;
        case BlendFactor_SRC_ALPHA:
            return D3DBLEND_SRCALPHA;
        case BlendFactor_INV_SRC_ALPHA:
            return D3DBLEND_INVSRCALPHA;
        case BlendFactor_DST_COLOR:
            return D3DBLEND_DESTCOLOR;
        case BlendFactor_INV_DST_COLOR:
            return D3DBLEND_INVDESTCOLOR;
        case BlendFactor_DST_ALPHA:
            return D3DBLEND_DESTALPHA;
        case BlendFactor_INV_DST_ALPHA:
            return D3DBLEND_INVDESTALPHA;
    }
    return 0;
}
void        Metal_BindTexture(Texture* texture, int index) {
    HRESULT result;

    if (!texture) {
        result = IDirect3DDevice9_SetTexture(renderData->Device, index, NULL);
        if (FAILED(result)) {
            Metal_SetError("SetTexture() %s", result);
        }
        return;
    }

    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;

    IDirect3DDevice9_SetSamplerState(renderData->Device, index, D3DSAMP_MINFILTER, textureData->ScaleMode);
    IDirect3DDevice9_SetSamplerState(renderData->Device, index, D3DSAMP_MAGFILTER, textureData->ScaleMode);
    IDirect3DDevice9_SetSamplerState(renderData->Device, index, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
    IDirect3DDevice9_SetSamplerState(renderData->Device, index, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);

    if (textureData->Dirty && textureData->Staging) {
        if (!textureData->Texture) {
            result = IDirect3DDevice9_CreateTexture(renderData->Device, texture->Width, texture->Height, 1, textureData->Usage, Metal_PixelFormatToD3DFORMAT(texture->Format), D3DPOOL_DEFAULT, &textureData->Texture, NULL);
            if (FAILED(result)) {
                Metal_SetError("CreateTexture(D3DPOOL_DEFAULT)", result);
            }
        }

        result = IDirect3DDevice9_UpdateTexture(renderData->Device, (IDirect3DBaseTexture9*)textureData->Staging, (IDirect3DBaseTexture9*)textureData->Texture);
        if (FAILED(result)) {
            Metal_SetError("UpdateTexture()", result);
        }
        textureData->Dirty = false;
    }

    result = IDirect3DDevice9_SetTexture(renderData->Device, index, (IDirect3DBaseTexture9*)textureData->Texture);
    if (FAILED(result)) {
        Metal_SetError("SetTexture() %s", result);
    }
}

void        Metal_DrawTextureRaw(Texture* texture, float sx, float sy, float sw, float sh, float x, float y, float w, float h, bool flipX, bool flipY) {
    HRESULT result;
    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;

    LPDIRECT3DPIXELSHADER9 shader = (LPDIRECT3DPIXELSHADER9)NULL;

    Metal_Predraw();

    float minu = (sx) / texture->Width;
    float maxu = (sx + sw) / texture->Width;
    float minv = (sy) / texture->Height;
    float maxv = (sy + sh) / texture->Height;
    DWORD color = 0xFFFFFFFF;
    if (Graphics::TextureBlend)
        color = Metal_BlendColorsAsHex;

    float minx = x;
    float maxx = x + w;
    float miny = y;
    float maxy = y + h;

    // NOTE: We do this because Direct3D9's origin for render targets is top-left,
    //    instead of the usual bottom-left.
    if (texture->Access == SDL_TEXTUREACCESS_TARGET) {
        // miny = y + h;
        // maxy = y;
        // if (Graphics::CurrentRenderTarget != NULL)
        //     flipY = !flipY;
        maxv = (sy) / texture->Height;
        minv = (sy + sh) / texture->Height;
    }

    Vertex vertices[4];
    // vertices[0] = Vertex { minx, miny, 0.0f, color, minu, minv };
    // vertices[1] = Vertex { maxx, miny, 0.0f, color, maxu, minv };
    // vertices[2] = Vertex { maxx, maxy, 0.0f, color, maxu, maxv };
    // vertices[3] = Vertex { minx, maxy, 0.0f, color, minu, maxv };
    vertices[0] = Vertex { 0.0f, 0.0f, 0.0f, color, minu, minv };
    vertices[1] = Vertex { 1.0f, 0.0f, 0.0f, color, maxu, minv };
    vertices[2] = Vertex { 1.0f, 1.0f, 0.0f, color, maxu, maxv };
    vertices[3] = Vertex { 0.0f, 1.0f, 0.0f, color, minu, maxv };

    if (Metal_PixelPerfectScale) {
        Point points[4];
        for (int i = 0; i < 4; i++) {
            points[i] = Graphics::ProjectToScreen(vertices[i].x, vertices[i].y, vertices[i].z);
            vertices[i].x = points[i].X ;
            vertices[i].y = points[i].Y;
            vertices[i].z = points[i].Z;
        }
    }

    // NOTE: This is not necessary in D3D10 and onwards
    float fx = flipX ? -1.0f : 1.0f;
    float fy = flipY ? -1.0f : 1.0f;
    // if (Graphics::CurrentRenderTarget) {
    //     for (int i = 0; i < 4; i++) {
    //         vertices[i].x -= 0.5f * fx;
    //         vertices[i].y += 0.5f * fy; // NOTE: Note the plus here, instead of minus
    //     }
    // }
    // else {
    //     for (int i = 0; i < 4; i++) {
    //         vertices[i].x -= 0.5f * fx;
    //         vertices[i].y -= 0.5f * fy;
    //     }
    // }

    Metal_SetBlendMode();
    Metal_BindTexture(texture, 0);

    if (shader) {
        // result = IDirect3DDevice9_SetPixelShader(renderData->Device, shader);
        // if (FAILED(result)) {
        //     return Metal_SetError("SetShader()", result);
        // }
    }

    D3DMATRIX matrix;
    if (Metal_PixelPerfectScale) {
        memcpy(&matrix.m, Metal_MatrixIdentity->Values, sizeof(float) * 16);
    }
    else {
        // memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        Graphics::Save();
        Graphics::Translate(x, y, 0.0f);
        if (texture->Access != SDL_TEXTUREACCESS_TARGET)
            Graphics::Translate(-0.5f * fx, 0.5f * fy, 0.0f);
        else
            Graphics::Translate(-0.5f * fx, -0.5f * fy, 0.0f);
        Graphics::Scale(w, h, 1.0f);
            memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        Graphics::Restore();
    }
    IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);

    result = IDirect3DDevice9_DrawPrimitiveUP(renderData->Device, D3DPT_TRIANGLEFAN, 2, vertices, sizeof(*vertices));
    if (FAILED(result)) {
        Metal_SetError("DrawPrimitiveUP() %s", result);
    }

    if (shader) {
        // IDirect3DDevice9_SetPixelShader(renderData->Device, NULL);
    }
    // return FAILED(result) ? -1 : 0;
}

void        Metal_BeginDrawShape(Vertex* shapeBuffer, int vertexCount) {
    Metal_Predraw();

    Vertex* buffer = (Vertex*)shapeBuffer;
    for (int i = 0; i < vertexCount; i++) {
        buffer[i].color = Metal_BlendColorsAsHex;
    }

    Metal_SetBlendMode();
    Metal_BindTexture(NULL, 0);
}
void        Metal_EndDrawShape(Vertex* shapeBuffer, D3DPRIMITIVETYPE prim, int triangleCount) {
    HRESULT result = IDirect3DDevice9_DrawPrimitiveUP(renderData->Device, prim, triangleCount, shapeBuffer, sizeof(Vertex));
    if (FAILED(result))
        Metal_SetError("DrawPrimitiveUP() %s", result);
}

// Initialization and disposal functions
PUBLIC STATIC void     MetalRenderer::Init() {
    Graphics::PreferredPixelFormat = SDL_PIXELFORMAT_ARGB8888;
    Metal_MatrixIdentity = Matrix4x4::Create();

    renderData = (Metal_RenderData*)calloc(1, sizeof(Metal_RenderData));

    // renderData->D3D = Direct3DCreate9(Metal_SDK_VERSION);
    if (!Metal_LoadDLL(&renderData->Metal_DLL, &renderData->D3D)) {
        Log::Print(Log::LOG_ERROR, "Unable to create Direct3D interface.");
        return;
    }

    Log::Print(Log::LOG_INFO, "Renderer: Direct3D 9");

    D3DCAPS9 caps;
    HRESULT result;
    DWORD device_flags;
    Uint32 window_flags;
    SDL_SysWMinfo windowinfo;
    IDirect3DSwapChain9* chain;
    D3DPRESENT_PARAMETERS pparams;
    SDL_DisplayMode fullscreen_mode;
    int displayIndex, w, h, texture_max_w, texture_max_h;

	SDL_VERSION(&windowinfo.version);
    SDL_GetWindowWMInfo(Application::Window, &windowinfo);

    window_flags = SDL_GetWindowFlags(Application::Window);
    SDL_GetWindowSize(Application::Window, &w, &h);
    SDL_GetWindowDisplayMode(Application::Window, &fullscreen_mode);

    memset(&pparams, 0, sizeof(pparams));
    pparams.hDeviceWindow = windowinfo.info.win.window;
    pparams.BackBufferWidth = w;
    pparams.BackBufferHeight = h;
    pparams.BackBufferCount = 1;
    pparams.SwapEffect = D3DSWAPEFFECT_DISCARD;

    pparams.EnableAutoDepthStencil = TRUE;
    pparams.AutoDepthStencilFormat = D3DFMT_D16;

    if (window_flags & SDL_WINDOW_FULLSCREEN && (window_flags & SDL_WINDOW_FULLSCREEN_DESKTOP) != SDL_WINDOW_FULLSCREEN_DESKTOP) {
        pparams.Windowed = FALSE;
        pparams.BackBufferFormat = Metal_PixelFormatToD3DFORMAT(fullscreen_mode.format);
        pparams.FullScreen_RefreshRateInHz = fullscreen_mode.refresh_rate;
    }
    else {
        pparams.Windowed = TRUE;
        pparams.BackBufferFormat = D3DFMT_UNKNOWN;
        pparams.FullScreen_RefreshRateInHz = 0;
    }

    if (Graphics::VsyncEnabled) {
        pparams.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    }
    else {
        pparams.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }

    displayIndex = SDL_GetWindowDisplayIndex(Application::Window);
    renderData->Adapter = SDL_Direct3D9GetAdapterIndex(displayIndex);

    // Check for full-scene antialiasing
    if (Graphics::MultisamplingEnabled) {
        pparams.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES;
        if (SUCCEEDED(result = IDirect3D9_CheckDeviceMultiSampleType(renderData->D3D, renderData->Adapter,
            D3DDEVTYPE_HAL,
            Metal_PixelFormatToD3DFORMAT(SDL_GetWindowPixelFormat(Application::Window)),
            pparams.Windowed,
            pparams.MultiSampleType, NULL))) {
            pparams.SwapEffect = D3DSWAPEFFECT_DISCARD;
        }
        else if (FAILED(result)) {
            pparams.MultiSampleType = D3DMULTISAMPLE_NONE;
            Graphics::MultisamplingEnabled = 0;
        }
    }

    IDirect3D9_GetDeviceCaps(renderData->D3D, renderData->Adapter, D3DDEVTYPE_HAL, &caps);

    device_flags = D3DCREATE_FPU_PRESERVE;
    if (caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)
        device_flags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
    else
        device_flags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

    if (SDL_GetHintBoolean(SDL_HINT_RENDER_DIRECT3D_THREADSAFE, SDL_FALSE)) {
        device_flags |= D3DCREATE_MULTITHREADED;
    }

    result = IDirect3D9_CreateDevice(
        renderData->D3D, renderData->Adapter,
        D3DDEVTYPE_HAL,
        pparams.hDeviceWindow,
        device_flags,
        &pparams, &renderData->Device);
    if (FAILED(result)) {
        MetalRenderer::Dispose();
        Log::Print(Log::LOG_ERROR, "CreateDevice() %s", Metal_GetResultString(result));
        exit(0);
    }

    /* Get presentation parameters to fill info */
    result = IDirect3DDevice9_GetSwapChain(renderData->Device, 0, &chain);
    if (FAILED(result)) {
        MetalRenderer::Dispose();
        Log::Print(Log::LOG_ERROR, "GetSwapChain() %d", result);
        return;
    }
    result = IDirect3DSwapChain9_GetPresentParameters(chain, &pparams);
    if (FAILED(result)) {
        IDirect3DSwapChain9_Release(chain);
        MetalRenderer::Dispose();
        Log::Print(Log::LOG_ERROR, "GetPresentParameters() %d", result);
        return;
    }
    IDirect3DSwapChain9_Release(chain);
    if (pparams.PresentationInterval == D3DPRESENT_INTERVAL_ONE) {
        Graphics::VsyncEnabled = true;
    }
    renderData->PresentParams = pparams;

    IDirect3DDevice9_GetDeviceCaps(renderData->Device, &caps);
    texture_max_w = caps.MaxTextureWidth;
    texture_max_h = caps.MaxTextureHeight;
    if (caps.NumSimultaneousRTs >= 2) {
        // renderer->info.flags |= SDL_RENDERER_TARGETTEXTURE;
    }

    if (caps.PrimitiveMiscCaps & D3DPMISCCAPS_SEPARATEALPHABLEND) {
        renderData->EnableSeparateAlphaBlend = SDL_TRUE;
    }

    /* Store the default render target */
    IDirect3DDevice9_GetRenderTarget(renderData->Device, 0, &renderData->DefaultRenderTarget);
    renderData->CurrentRenderTarget = NULL;

    /* Set up parameters for rendering */
    Metal_InitRenderState();

    if (caps.MaxSimultaneousTextures >= 3) {
        // int i;
        // for (i = 0; i < SDL_arraysize(MetalRenderer::shaders); ++i) {
        //     result = D3D9_CreatePixelShader(renderData->Device, (D3D9_Shader)i, &MetalRenderer::shaders[i]);
        //     if (FAILED(result)) {
        //         Metal_SetError("CreatePixelShader()", result);
        //     }
        // }
        // if (MetalRenderer::shaders[SHADER_YUV_JPEG] && MetalRenderer::shaders[SHADER_YUV_BT601] && MetalRenderer::shaders[SHADER_YUV_BT709]) {
        //     renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_YV12;
        //     renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_IYUV;
        // }
    }

    Metal_MakeShaders();
    Metal_MakeShapeBuffers();

    UseShader(Metal_ShaderShape);

    Graphics::MaxTextureWidth = texture_max_w;
    Graphics::MaxTextureHeight = texture_max_h;

    D3DADAPTER_IDENTIFIER9 indent;
    IDirect3D9_GetAdapterIdentifier(renderData->D3D, renderData->Adapter, 0, &indent);

    Log::Print(Log::LOG_INFO, "Graphics Card: %s", indent.Description);
}
PUBLIC STATIC Uint32   MetalRenderer::GetWindowFlags() {
    return SDL_WINDOW_METAL;
}
PUBLIC STATIC void     MetalRenderer::SetGraphicsFunctions() {
    Graphics::PixelOffset = 0.5f;

    Graphics::Internal.Init = MetalRenderer::Init;
    Graphics::Internal.GetWindowFlags = MetalRenderer::GetWindowFlags;
    Graphics::Internal.Dispose = MetalRenderer::Dispose;

    // Texture management functions
    Graphics::Internal.CreateTexture = MetalRenderer::CreateTexture;
    Graphics::Internal.LockTexture = MetalRenderer::LockTexture;
    Graphics::Internal.UpdateTexture = MetalRenderer::UpdateTexture;
    Graphics::Internal.UnlockTexture = MetalRenderer::UnlockTexture;
    Graphics::Internal.DisposeTexture = MetalRenderer::DisposeTexture;

    // Viewport and view-related functions
    Graphics::Internal.SetRenderTarget = MetalRenderer::SetRenderTarget;
    Graphics::Internal.UpdateWindowSize = MetalRenderer::UpdateWindowSize;
    Graphics::Internal.UpdateViewport = MetalRenderer::UpdateViewport;
    Graphics::Internal.UpdateClipRect = MetalRenderer::UpdateClipRect;
    Graphics::Internal.UpdateOrtho = MetalRenderer::UpdateOrtho;
    Graphics::Internal.UpdatePerspective = MetalRenderer::UpdatePerspective;
    Graphics::Internal.UpdateProjectionMatrix = MetalRenderer::UpdateProjectionMatrix;

    // Shader-related functions
    Graphics::Internal.UseShader = MetalRenderer::UseShader;
    Graphics::Internal.SetUniformF = MetalRenderer::SetUniformF;
    Graphics::Internal.SetUniformI = MetalRenderer::SetUniformI;
    Graphics::Internal.SetUniformTexture = MetalRenderer::SetUniformTexture;

    // These guys
    Graphics::Internal.Clear = MetalRenderer::Clear;
    Graphics::Internal.Present = MetalRenderer::Present;

    // Draw mode setting functions
    Graphics::Internal.SetBlendColor = MetalRenderer::SetBlendColor;
    Graphics::Internal.SetBlendMode = MetalRenderer::SetBlendMode;
    Graphics::Internal.SetLineWidth = MetalRenderer::SetLineWidth;

    // Primitive drawing functions
    Graphics::Internal.StrokeLine = MetalRenderer::StrokeLine;
    Graphics::Internal.StrokeCircle = MetalRenderer::StrokeCircle;
    Graphics::Internal.StrokeEllipse = MetalRenderer::StrokeEllipse;
    Graphics::Internal.StrokeRectangle = MetalRenderer::StrokeRectangle;
    Graphics::Internal.FillCircle = MetalRenderer::FillCircle;
    Graphics::Internal.FillEllipse = MetalRenderer::FillEllipse;
    Graphics::Internal.FillTriangle = MetalRenderer::FillTriangle;
    Graphics::Internal.FillRectangle = MetalRenderer::FillRectangle;

    // Texture drawing functions
    Graphics::Internal.DrawTexture = MetalRenderer::DrawTexture;
    Graphics::Internal.DrawSprite = MetalRenderer::DrawSprite;
    Graphics::Internal.DrawSpritePart = MetalRenderer::DrawSpritePart;
}
PUBLIC STATIC void     MetalRenderer::Dispose() {
    Memory::Free(Metal_BufferCircleFill);
    Memory::Free(Metal_BufferCircleStroke);
    Memory::Free(Metal_BufferSquareFill);

    // Metal_ShaderShape->Dispose(); delete Metal_ShaderShape;
    // Metal_ShaderTexturedShape->Dispose(); delete Metal_ShaderTexturedShape;
    // ShaderTexturedShapeYUV->Dispose(); delete ShaderTexturedShapeYUV;
    // ShaderTexturedShapeBlur->Dispose(); delete ShaderTexturedShapeBlur;
}

// Texture management functions
PUBLIC STATIC Texture* MetalRenderer::CreateTexture(Uint32 format, Uint32 access, Uint32 width, Uint32 height) {
    Texture* texture = Texture::New(format, access, width, height);

    Metal_CreateTexture(texture);

    texture->ID = Graphics::TextureMap->Count + 1;
    Graphics::TextureMap->Put(texture->ID, texture);

    return texture;
}
PUBLIC STATIC int      MetalRenderer::LockTexture(Texture* texture, void** pixels, int* pitch) {
    return 0;
}
PUBLIC STATIC int      MetalRenderer::UpdateTexture(Texture* texture, SDL_Rect* r, void* pixels, int pitch) {
    int inputPixelsX = 0;
    int inputPixelsY = 0;
    int inputPixelsW = texture->Width;
    int inputPixelsH = texture->Height;
    if (r) {
        inputPixelsX = r->x;
        inputPixelsY = r->y;
        inputPixelsW = r->w;
        inputPixelsH = r->h;
    }

    if (Graphics::NoInternalTextures) {
        if (inputPixelsW > Graphics::MaxTextureWidth)
            inputPixelsW = Graphics::MaxTextureWidth;
        if (inputPixelsH > Graphics::MaxTextureHeight)
            inputPixelsH = Graphics::MaxTextureHeight;
    }

    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;

    RECT d3drect;
    D3DLOCKED_RECT locked;
    const Uint8 *src;
    Uint8 *dst;
    int row, length;
    HRESULT result;

    d3drect.left   = inputPixelsX;
    d3drect.right  = inputPixelsX + inputPixelsW;
    d3drect.top    = inputPixelsY;
    d3drect.bottom = inputPixelsY + inputPixelsH;

    if (textureData->Staging == NULL) {
        result = IDirect3DDevice9_CreateTexture(renderData->Device, texture->Width, texture->Height, 1, 0, textureData->D3DFormat, D3DPOOL_SYSTEMMEM, &textureData->Staging, NULL);
        if (FAILED(result)) {
            return Metal_SetError("CreateTexture(D3DPOOL_SYSTEMMEM)", result);
        }
    }

    result = IDirect3DTexture9_LockRect(textureData->Staging, 0, &locked, &d3drect, 0);
    if (FAILED(result)) {
        Metal_SetError("LockRect() %s", result);
        return -1;
    }

    src = (const Uint8*)pixels;
    dst = (Uint8*)locked.pBits;
    length = inputPixelsW * SDL_BYTESPERPIXEL(texture->Format);
    if (length == pitch && length == locked.Pitch) {
        memcpy(dst, src, length * inputPixelsH);
    }
    else {
        if (length > pitch) {
            length = pitch;
        }
        if (length > locked.Pitch) {
            length = locked.Pitch;
        }
        for (row = 0; row < inputPixelsH; ++row) {
            memcpy(dst, src, length);
            src += pitch;
            dst += locked.Pitch;
        }
    }
    result = IDirect3DTexture9_UnlockRect(textureData->Staging, 0);
    if (FAILED(result)) {
        Metal_SetError("UnlockRect() %s", result);
        return -1;
    }
    textureData->Dirty = true;

    return 0;
}
PUBLIC STATIC void     MetalRenderer::UnlockTexture(Texture* texture) {

}
PUBLIC STATIC void     MetalRenderer::DisposeTexture(Texture* texture) {
    Metal_TextureData* textureData = (Metal_TextureData*)texture->DriverData;
    if (!textureData)
        return;

    if (textureData->Texture) {
        IDirect3DTexture9_Release(textureData->Texture);
        textureData->Texture = NULL;
    }
    if (textureData->Staging) {
        IDirect3DTexture9_Release(textureData->Staging);
        textureData->Staging = NULL;
    }

    // free(texture->Pixels);
    Memory::Free(texture->DriverData);

    texture->DriverData = NULL;
}

// Viewport and view-related functions
PUBLIC STATIC void     MetalRenderer::SetRenderTarget(Texture* texture) {
    Metal_Predraw();
    Metal_SetRenderTarget(texture);
}
PUBLIC STATIC void     MetalRenderer::UpdateWindowSize(int width, int height) {
    // Metal_UpdateViewport(0, 0, width, height);
    renderData->UpdateBackBufferSize = true;
}
PUBLIC STATIC void     MetalRenderer::UpdateViewport() {
    Viewport* vp = &Graphics::CurrentViewport;

    D3DVIEWPORT9 viewport;
    viewport.X = vp->X;
    viewport.Y = vp->Y;
    viewport.Width = vp->Width;
    viewport.Height = vp->Height; // * RetinaScale
    viewport.MinZ = 0.0f;
    viewport.MaxZ = 1.0f;
    IDirect3DDevice9_SetViewport(renderData->Device, &viewport);

    // NOTE: According to SDL2 we should be setting projection matrix here.
    // MetalRenderer::UpdateOrtho(vp->Width, vp->Height);
    MetalRenderer::UpdateProjectionMatrix();
}
PUBLIC STATIC void     MetalRenderer::UpdateClipRect() {
    ClipArea clip = Graphics::CurrentClip;
    if (Graphics::CurrentClip.Enabled) {
        Viewport view = Graphics::CurrentViewport;

        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SCISSORTESTENABLE, TRUE);


        int w, h;
        float scaleW = 1.0f, scaleH = 1.0f;
        SDL_GetWindowSize(Application::Window, &w, &h);
        View* currentView = &Scene::Views[Scene::ViewCurrent];
        scaleW *= w / currentView->Width;
        scaleH *= h / currentView->Height;

        RECT r;
        r.left   = view.X + (int)((clip.X) * scaleW);
        r.top    = view.Y + (int)((clip.Y) * scaleH);
        r.right  = view.X + (int)((clip.X + clip.Width) * scaleW);
        r.bottom = view.Y + (int)((clip.Y + clip.Height) * scaleH);

        HRESULT result = IDirect3DDevice9_SetScissorRect(renderData->Device, &r);
        if (result != Metal_OK) {
            Metal_SetError("SetScissor()", result);
        }
    }
    else {
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SCISSORTESTENABLE, FALSE);
    }
}
PUBLIC STATIC void     MetalRenderer::UpdateOrtho(float left, float top, float right, float bottom) {
    if (Scene::Views[Scene::ViewCurrent].Software)
        Matrix4x4::Ortho(Scene::Views[Scene::ViewCurrent].BaseProjectionMatrix, left, right, bottom, top, 500.0f, -500.0f);
    else
        Matrix4x4::Ortho(Scene::Views[Scene::ViewCurrent].BaseProjectionMatrix, left, right, top, bottom, 500.0f, -500.0f);
    Matrix4x4::Copy(Scene::Views[Scene::ViewCurrent].ProjectionMatrix, Scene::Views[Scene::ViewCurrent].BaseProjectionMatrix);

    if (Metal_PixelPerfectScale) {
        Metal_RenderScaleX = Graphics::CurrentViewport.Width / right;
        Metal_RenderScaleY = Graphics::CurrentViewport.Height / top;
    }
}
PUBLIC STATIC void     MetalRenderer::UpdatePerspective(float fovy, float aspect, float nearv, float farv) {
    Matrix4x4::Perspective(Scene::Views[Scene::ViewCurrent].BaseProjectionMatrix, fovy, aspect, nearv, farv);
    Matrix4x4::Copy(Scene::Views[Scene::ViewCurrent].ProjectionMatrix, Scene::Views[Scene::ViewCurrent].BaseProjectionMatrix);
}
PUBLIC STATIC void     MetalRenderer::UpdateProjectionMatrix() {
    D3DMATRIX matrix;
    memcpy(&matrix.m, Scene::Views[Scene::ViewCurrent].ProjectionMatrix->Values, sizeof(float) * 16);
    IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_PROJECTION, &matrix);
}

// Shader-related functions
PUBLIC STATIC void     MetalRenderer::UseShader(void* shader) {
    if (Metal_CurrentShader != (MetalShader*)shader) {
        Metal_CurrentShader = (MetalShader*)shader;
        Metal_CurrentShader->Use();
    }
}
PUBLIC STATIC void     MetalRenderer::SetUniformF(int location, int count, float* values) {
    // switch (count) {
    //     case 1: glUniform1f(location, values[0]); CHECK_GL(); break;
    //     case 2: glUniform2f(location, values[0], values[1]); CHECK_GL(); break;
    //     case 3: glUniform3f(location, values[0], values[1], values[2]); CHECK_GL(); break;
    //     case 4: glUniform4f(location, values[0], values[1], values[2], values[3]); CHECK_GL(); break;
    // }
}
PUBLIC STATIC void     MetalRenderer::SetUniformI(int location, int count, int* values) {
    // glUniform1iv(location, count, values);
}
PUBLIC STATIC void     MetalRenderer::SetUniformTexture(Texture* texture, int uniform_index, int slot) {

}

// These guys
PUBLIC STATIC void     MetalRenderer::Clear() {
    DWORD color;
    HRESULT result;
    int BackBufferWidth, BackBufferHeight;

    Metal_Predraw();

    if (Graphics::CurrentRenderTarget) {
        BackBufferWidth = Graphics::CurrentRenderTarget->Width;
        BackBufferHeight = Graphics::CurrentRenderTarget->Height;
    }
    else {
        BackBufferWidth = renderData->PresentParams.BackBufferWidth;
        BackBufferHeight = renderData->PresentParams.BackBufferHeight;
    }

    if (Graphics::CurrentClip.Enabled)
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SCISSORTESTENABLE, FALSE);

    DWORD clear_flags = D3DCLEAR_TARGET;

    clear_flags |= D3DCLEAR_ZBUFFER;

    color = 0x00000000;

    /* Don't reset the viewport if we don't have to! */
    Viewport* vp = &Graphics::CurrentViewport;
    if (vp->X == 0.0 &&
        vp->Y == 0.0 &&
        vp->Width == BackBufferWidth &&
        vp->Height == BackBufferHeight) {
        result = IDirect3DDevice9_Clear(renderData->Device, 0, NULL, clear_flags, color, 1.0f, 0);
    }
    else {
        D3DVIEWPORT9 viewport;

        /* Clear is defined to clear the entire render target */
        viewport.X = 0.0;
        viewport.Y = 0.0;
        viewport.Width = BackBufferWidth;
        viewport.Height = BackBufferHeight;
        viewport.MinZ = 0.0f;
        viewport.MaxZ = 1.0f;
        IDirect3DDevice9_SetViewport(renderData->Device, &viewport);

        result = IDirect3DDevice9_Clear(renderData->Device, 0, NULL, clear_flags, color, 1.0f, 0);

        /* Reset the viewport */
        viewport.X = vp->X;
        viewport.Y = vp->Y;
        viewport.Width = vp->Width;
        viewport.Height = vp->Height;
        viewport.MinZ = 0.0f;
        viewport.MaxZ = 1.0f;
        IDirect3DDevice9_SetViewport(renderData->Device, &viewport);
    }

    if (Graphics::CurrentClip.Enabled)
        IDirect3DDevice9_SetRenderState(renderData->Device, D3DRS_SCISSORTESTENABLE, TRUE);

    if (FAILED(result)) {
        Metal_SetError("Clear()", result);
    }
}
PUBLIC STATIC void     MetalRenderer::Present() {
    HRESULT result;

    if (!renderData->BeginScene) {
        IDirect3DDevice9_EndScene(renderData->Device);
        renderData->BeginScene = true;
    }

    result = IDirect3DDevice9_TestCooperativeLevel(renderData->Device);
    if (result == D3DERR_DEVICELOST) {
        /* We'll reset later */
        return;
    }
    if (result == D3DERR_DEVICENOTRESET) {
        Metal_Reset();
        // Metal_Reset(renderer);
    }

    result = IDirect3DDevice9_Present(renderData->Device, NULL, NULL, NULL, NULL);
    if (FAILED(result)) {
        Metal_SetError("Present()", result);
    }
}

// Draw mode setting functions
PUBLIC STATIC void     MetalRenderer::SetBlendColor(float r, float g, float b, float a) {
    int ha = (int)(a * 0xFF) << 24;
    int hr = (int)(r * 0xFF) << 16;
    int hg = (int)(g * 0xFF) << 8;
    int hb = (int)(b * 0xFF);
    Metal_BlendColorsAsHex = ha | hr | hg | hb;
}
PUBLIC STATIC void     MetalRenderer::SetBlendMode(int srcC, int dstC, int srcA, int dstA) {
    Metal_Blend_SRC_COLOR = Metal_GetBlendFactorFromHatch(srcC);
    Metal_Blend_DST_COLOR = Metal_GetBlendFactorFromHatch(dstC);
    Metal_Blend_SRC_ALPHA = Metal_GetBlendFactorFromHatch(srcA);
    Metal_Blend_DST_ALPHA = Metal_GetBlendFactorFromHatch(dstA);
}
PUBLIC STATIC void     MetalRenderer::SetLineWidth(float n) {
    // glLineWidth(n);
}

// Primitive drawing functions
PUBLIC STATIC void     MetalRenderer::StrokeLine(float x1, float y1, float x2, float y2) {
    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderShape);

    Graphics::Save();
        // glUniformMatrix4fv(Metal_CurrentShader->LocModelViewMatrix, 1, false, Graphics::ModelViewMatrix.top()->Values);

        float v[6];
        v[0] = x1; v[1] = y1; v[2] = 0.0f;
        v[3] = x2; v[4] = y2; v[5] = 0.0f;

        // glBindBuffer(GL_ARRAY_BUFFER, 0);
        // glVertexAttribPointer(Metal_CurrentShader->LocPosition, 3, GL_FLOAT, GL_FALSE, 0, v);
        // glDrawArrays(GL_LINES, 0, 2);
    Graphics::Restore();
}
PUBLIC STATIC void     MetalRenderer::StrokeCircle(float x, float y, float rad) {
    Metal_BeginDrawShape(Metal_BufferCircleStroke, 361);

    Graphics::Save();
    Graphics::Translate(x, y, 0.0f);
    Graphics::Scale(rad, rad, 1.0f);
        D3DMATRIX matrix;
        memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);
    Graphics::Restore();

    Metal_EndDrawShape(Metal_BufferCircleStroke, D3DPT_LINESTRIP, 360);
}
PUBLIC STATIC void     MetalRenderer::StrokeEllipse(float x, float y, float w, float h) {
    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderShape);

    Graphics::Save();
    Graphics::Translate(x + w / 2, y + h / 2, 0.0f);
    Graphics::Scale(w / 2, h / 2, 1.0f);
        // glUniformMatrix4fv(Metal_CurrentShader->LocModelViewMatrix, 1, false, Graphics::ModelViewMatrix.top()->Values);

        // glBindBuffer(GL_ARRAY_BUFFER, Metal_BufferCircleStroke);
        // glVertexAttribPointer(Metal_CurrentShader->LocPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);
        // glDrawArrays(GL_LINE_STRIP, 0, 361);
    Graphics::Restore();
}
PUBLIC STATIC void     MetalRenderer::StrokeRectangle(float x, float y, float w, float h) {
    StrokeLine(x, y, x + w, y);
    StrokeLine(x, y + h, x + w, y + h);

    StrokeLine(x, y, x, y + h);
    StrokeLine(x + w, y, x + w, y + h);
}
PUBLIC STATIC void     MetalRenderer::FillCircle(float x, float y, float rad) {
    Metal_BeginDrawShape(Metal_BufferCircleFill, 362);

    Graphics::Save();
    Graphics::Translate(x, y, 0.0f);
    Graphics::Scale(rad, rad, 1.0f);
        D3DMATRIX matrix;
        memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);
    Graphics::Restore();

    Metal_EndDrawShape(Metal_BufferCircleFill, D3DPT_TRIANGLEFAN, 360);
}
PUBLIC STATIC void     MetalRenderer::FillEllipse(float x, float y, float w, float h) {
    Metal_BeginDrawShape(Metal_BufferCircleFill, 362);

    w *= 0.5f;
    h *= 0.5f;

    Graphics::Save();
    Graphics::Translate(x + w, y + h, 0.0f);
    Graphics::Scale(w, h, 1.0f);
        D3DMATRIX matrix;
        memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);
    Graphics::Restore();

    Metal_EndDrawShape(Metal_BufferCircleFill, D3DPT_TRIANGLEFAN, 360);
}
PUBLIC STATIC void     MetalRenderer::FillTriangle(float x1, float y1, float x2, float y2, float x3, float y3) {
    Vertex vertices[3];
    vertices[0] = Vertex { x1, y1, 0.0f, Metal_BlendColorsAsHex, 0.0f, 0.0f };
    vertices[1] = Vertex { x2, y2, 0.0f, Metal_BlendColorsAsHex, 0.0f, 0.0f };
    vertices[2] = Vertex { x3, y3, 0.0f, Metal_BlendColorsAsHex, 0.0f, 0.0f };

    Metal_BeginDrawShape(vertices, 3);

    D3DMATRIX matrix;
    memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
    IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);

    Metal_EndDrawShape(vertices, D3DPT_TRIANGLEFAN, 1);
}
PUBLIC STATIC void     MetalRenderer::FillRectangle(float x, float y, float w, float h) {
    Metal_BeginDrawShape(Metal_BufferSquareFill, 4);

    Graphics::Save();
    Graphics::Translate(x, y, 0.0f);
    Graphics::Scale(w, h, 1.0f);
        D3DMATRIX matrix;
        memcpy(&matrix.m, Graphics::ModelViewMatrix.top()->Values, sizeof(float) * 16);
        IDirect3DDevice9_SetTransform(renderData->Device, D3DTS_VIEW, &matrix);
    Graphics::Restore();

    Metal_EndDrawShape(Metal_BufferSquareFill, D3DPT_TRIANGLEFAN, 2);
}

// Texture drawing functions
PUBLIC STATIC void     MetalRenderer::DrawTexture(Texture* texture, float sx, float sy, float sw, float sh, float x, float y, float w, float h) {
    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderTexturedShape);
    if (sx < 0)
        sx = 0.0, sy = 0.0, sw = texture->Width, sh = texture->Height;
    Metal_DrawTextureRaw(texture, sx, sy, sw, sh, x, y, w, h, false, texture->Access != SDL_TEXTUREACCESS_TARGET);
}
PUBLIC STATIC void     MetalRenderer::DrawSprite(ISprite* sprite, int animation, int frame, int x, int y, bool flipX, bool flipY, float scaleW, float scaleH, float rotation) {
	if (Graphics::SpriteRangeCheck(sprite, animation, frame)) return;

	AnimFrame animframe = sprite->Animations[animation].Frames[frame];

	float fX = flipX ? -1.0 : 1.0;
	float fY = flipY ? -1.0 : 1.0;
	// DrawTexture(sprite->Spritesheets[animframe.SheetNumber], animframe.X, animframe.Y, animframe.W, animframe.H, x + fX * animframe.OffX, y + fY * animframe.OffY, fX * animframe.W, fY * animframe.H);

    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderTexturedShape);
    Graphics::Save();
    Graphics::Translate(x, y, 0.0f);
    Graphics::Scale(fX, fY, 1.0f);
        Metal_DrawTextureRaw(sprite->Spritesheets[animframe.SheetNumber], animframe.X, animframe.Y, animframe.Width, animframe.Height, animframe.OffsetX, animframe.OffsetY, animframe.Width, animframe.Height, flipX, flipY);
    Graphics::Restore();
}
PUBLIC STATIC void     MetalRenderer::DrawSpritePart(ISprite* sprite, int animation, int frame, int sx, int sy, int sw, int sh, int x, int y, bool flipX, bool flipY, float scaleW, float scaleH, float rotation) {
    if (Graphics::SpriteRangeCheck(sprite, animation, frame)) return;

	AnimFrame animframe = sprite->Animations[animation].Frames[frame];
    if (sx == animframe.Width)
        return;
    if (sy == animframe.Height)
        return;

	float fX = flipX ? -1.0 : 1.0;
	float fY = flipY ? -1.0 : 1.0;
    if (sw >= animframe.Width - sx)
        sw  = animframe.Width - sx;
    if (sh >= animframe.Height - sy)
        sh  = animframe.Height - sy;

    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderTexturedShape);
    Graphics::Save();
    Graphics::Translate(x, y, 0.0f);
    Graphics::Scale(fX, fY, 1.0f);
        Metal_DrawTextureRaw(sprite->Spritesheets[animframe.SheetNumber],
            animframe.X + sx, animframe.Y + sy,
            sw, sh,
            sx + animframe.OffsetX, sy + animframe.OffsetY,
            sw, sh,
            flipX, flipY);
    Graphics::Restore();
}

/*
// Draw buffering
PUBLIC STATIC Uint32   MetalRenderer::CreateTexturedShapeBuffer(float** data, int vertexCount) {
    // x, y, z, u, v
    Uint32 bufferID;
    glGenBuffers(1, &bufferID);
    glBindBuffer(GL_ARRAY_BUFFER, bufferID);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertexCount * 5, data, GL_STATIC_DRAW);

    *data = NULL;

    return bufferID;
}

PUBLIC STATIC void     MetalRenderer::DrawTexturedShapeBuffer(Texture* texture, Uint32 bufferID, int vertexCount) {
    UseShader(Metal_SelectedShader ? Metal_SelectedShader : Metal_ShaderTexturedShape);

    GLTextureData* textureData = (GLTextureData*)texture->DriverData;
    glUniformMatrix4fv(MetalRenderer::Metal_CurrentShader->LocModelViewMatrix, 1, false, MetalRenderer::Graphics::ModelViewMatrix.top()->Values);

    glActiveTexture(GL_TEXTURE0);
    glUniform1i(MetalRenderer::Metal_CurrentShader->LocTexture, 0);
    glBindTexture(GL_TEXTURE_2D, textureData->TextureID);

    glEnableVertexAttribArray(MetalRenderer::Metal_CurrentShader->LocTexCoord);

        glBindBuffer(GL_ARRAY_BUFFER, bufferID);
        glVertexAttribPointer(MetalRenderer::Metal_CurrentShader->LocPosition, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 5, (GLvoid*)0);
        glVertexAttribPointer(MetalRenderer::Metal_CurrentShader->LocTexCoord, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 5, (GLvoid*)12);
        glDrawArrays(GL_TRIANGLES, 0, vertexCount);

    glDisableVertexAttribArray(MetalRenderer::Metal_CurrentShader->LocTexCoord);
}
//*/

#endif
